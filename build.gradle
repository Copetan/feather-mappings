import com.google.common.hash.Hashing
import com.google.common.io.Files
import com.google.common.net.UrlEscapers
import com.strobel.assembler.metadata.JarTypeLoader
import com.strobel.decompiler.Decompiler
import com.strobel.decompiler.DecompilerSettings
import com.strobel.decompiler.PlainTextOutput
import cuchaz.enigma.command.CheckMappingsCommand
import cuchaz.enigma.command.ComposeMappingsCommand
import cuchaz.enigma.command.ConvertMappingsCommand
import cuchaz.enigma.command.MapSpecializedMethodsCommand
import groovy.io.FileType
import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import net.fabricmc.stitch.commands.CommandMergeTiny
import net.fabricmc.stitch.commands.CommandProposeFieldNames
import net.fabricmc.stitch.commands.CommandReorderTiny
import net.fabricmc.stitch.commands.CommandRewriteCalamus
import net.fabricmc.stitch.commands.tinyv2.CommandMergeTinyV2
import net.fabricmc.stitch.commands.tinyv2.CommandProposeV2FieldNames
import net.fabricmc.stitch.commands.tinyv2.CommandReorderTinyV2
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import net.ornithemc.nester.Nester
import net.ornithemc.nester.nest.NesterIo
import net.ornithemc.nester.nest.Nests
import net.ornithemc.mappingutils.MappingUtils;
import net.ornithemc.mappingutils.PropagationDirection;
import net.ornithemc.mappingutils.PropagationOptions;
import net.ornithemc.mappingutils.io.Format;
import net.ornithemc.mappingutils.io.Mappings;
import net.ornithemc.mappingutils.io.Mappings.ClassMapping;
import net.ornithemc.mappingutils.io.Mappings.FieldMapping;
import net.ornithemc.mappingutils.io.Mappings.MethodMapping;
import net.ornithemc.mappingutils.io.Mappings.ParameterMapping;
import net.ornithemc.mappingutils.io.MappingTarget;
import net.ornithemc.mappingutils.io.MappingValidator;
import net.ornithemc.mappingutils.io.diff.DiffSide;
import net.ornithemc.mappingutils.io.diff.MappingsDiff;
import net.ornithemc.mappingutils.io.diff.MappingsDiff.ClassDiff;
import net.ornithemc.mappingutils.io.diff.MappingsDiff.Diff;
import net.ornithemc.mappingutils.io.diff.MappingsDiff.FieldDiff;
import net.ornithemc.mappingutils.io.diff.MappingsDiff.MethodDiff;
import net.ornithemc.mappingutils.io.diff.MappingsDiff.ParameterDiff;
import net.ornithemc.mappingutils.io.diff.MappingsDiffValidator;
import net.ornithemc.mappingutils.io.diff.graph.VersionGraph;
import org.apache.commons.io.FileUtils

import java.nio.charset.Charset
import java.nio.charset.StandardCharsets
import java.nio.file.Paths
import java.util.jar.JarFile
import java.util.zip.GZIPOutputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

buildscript {
	repositories {
		maven {
			name "Ornithe"
			url "https://maven.ornithemc.net/releases"
		}
		maven {
			name 'Quilt Repository'
			url 'https://maven.quiltmc.org/repository/release/'
		}
		maven {
			name 'Quilt Snapshot Repository'
			url 'https://maven.quiltmc.org/repository/snapshot/'
		}
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		maven {
			name "Vineflower Snapshots"
			url 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
		}
		mavenCentral()
	}
	dependencies {
		classpath "net.ornithemc:enigma-cli:${project.enigma_version}"
		classpath "net.ornithemc:stitch:${project.stitch_version}"
		classpath "net.ornithemc:tiny-remapper:0.8.4"
		classpath "net.ornithemc:nester:${project.nester_version}"
		classpath "net.ornithemc:mapping-utils:${project.mapping_utils_version}"
		classpath "commons-io:commons-io:2.8.0"
		classpath 'de.undercouch:gradle-download-task:4.1.1'
		classpath "org.quiltmc:quilt-enigma-plugin:${project.quilt_enigma_plugin_version}"
		classpath "net.fabricmc.unpick:unpick:${project.unpick_version}"
		classpath "net.fabricmc.unpick:unpick-format-utils:${project.unpick_version}"
		classpath "org.codehaus.groovy:groovy-json:3.0.9"
		classpath "org.codehaus.groovy:groovy-xml:3.0.9"
	}
}

plugins {
	id 'de.undercouch.download' version '4.1.1'
	id 'base'
	id 'maven-publish'
	id 'java' // for jd gen
	id 'org.cadixdev.licenser' version '0.6.1'
	id 'net.fabricmc.filament' version '0.3.0'
}

def ENV = System.getenv()
def version_id = ENV.MC_VERSION ?: {
	project.logger.error("MC_VERSION environment variable not set, defaulting to 1.3-pre-07261249")
	return "1.3-pre-07261249"
}()
def environment = parseEnvironment(version_id)
def minecraft_version = parseVersion(version_id, environment)
def featherVersion = nextFeatherVersion(ENV, version_id)

enum Environment {

	MERGED, CLIENT, SERVER

	public boolean isMerged() {
		return this == MERGED
	}

	public boolean isClient() {
		return this == MERGED || this == CLIENT
	}

	public boolean isServer() {
		return this == MERGED || this == SERVER
	}
}

static Environment parseEnvironment(String id) {
	if (id.endsWith("-client")) {
		return Environment.CLIENT
	}
	if (id.endsWith("-server")) {
		return Environment.SERVER
	}

	return Environment.MERGED
}

static String parseVersion(String id, Environment environment) {
	switch (environment) {
	case Environment.CLIENT:
		return id.substring(0, id.length() - "-client".length())
	case Environment.SERVER:
		return id.substring(0, id.length() - "-server".length())
	case Environment.MERGED:
		return id
	}
}

static def nextFeatherVersion(ENV, version_id) {
	if (ENV.MAVEN_URL) {
		def build_number = 0

		try {
			def xml = new URL("https://maven.ornithemc.net/releases/net/ornithemc/feather/maven-metadata.xml").text
			def metadata = new XmlSlurper().parseText(xml)

			def version_build = "${version_id}+build."
			def i = version_build.length()

			metadata.versioning.versions.version.each {
				def version = it.text()

				if (version.startsWith(version_build)) {
					def number_text = version.substring(i)
					try {
						def number = Integer.parseInt(number_text)

						if (number > build_number) {
							build_number = number
						}
					} catch (NumberFormatException e) {
						throw new RuntimeException(e);
					}
				}
			}
		} catch (FileNotFoundException e) {
			// Note: we consider it a hard failure if the maven-metadata.xml file does
			// not exist. However if you don't have this file yet, you can comment out
			// the line below to start at build number 1.
			throw new RuntimeException(e);
		}

		// is 0 if no version is found in the above
		def next_build_number = build_number + 1;

		return "${version_id}+build.${next_build_number}"
	} else {
		return "${version_id}+build.local"
	}
}

repositories {
	mavenCentral()
	maven {
		name "Ornithe"
		url "https://maven.ornithemc.net/releases"
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	maven {
		name 'Quilt Repository'
		url 'https://maven.quiltmc.org/repository/release/'
	}
	maven {
		name 'Quilt Snapshot Repository'
		url 'https://maven.quiltmc.org/repository/snapshot/'
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Procyon Repository"
		url 'https://oss.sonatype.org'
	}
	maven {
		name "Vineflower Snapshots"
		url 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
	}
}

configurations {
	enigmaRuntime
	javadocClasspath
	decompileClasspath
	mappingPoetJar {
		transitive = false
	}
	mappingPoet {
		extendsFrom mappingPoetJar
		transitive = true
	}
}

dependencies {
	enigmaRuntime "net.ornithemc:enigma-swing:${project.enigma_version}"
	enigmaRuntime "org.quiltmc:quilt-enigma-plugin:${project.quilt_enigma_plugin_version}"
	javadocClasspath "org.quiltmc:quilt-loader:${project.quilt_loader_version}"
	javadocClasspath "com.google.code.findbugs:jsr305:3.0.2"
	decompileClasspath "net.fabricmc:cfr:${project.cfr_version}"
	decompileClasspath "org.quiltmc:quiltflower:${project.quiltflower_version}"
	implementation "net.fabricmc:procyon-fabric-compilertools:${project.procyon_version}"
	mappingPoetJar "net.fabricmc:mappingpoet:${project.mapping_poet_version}"
}

def setupGroup = "jar setup"
def featherGroup = "feather"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"
def mappingsDir = file("mappings/")
def workingDir = file("run/")
def workingMappings = new File(workingDir, "${version_id}")
def cacheFilesMinecraft = new File(project.gradle.gradleUserHomeDir, "caches/feather-build-cache/")
def tempDir = file(".gradle/temp")
def mergedJar = new File(cacheFilesMinecraft, "merged/${version_id}-merged.jar")
def namedJarsDir = new File(cacheFilesMinecraft, "named-jars/")
def calamusJar = new File(namedJarsDir, "${version_id}-calamus.jar")
def nestedJar = new File(namedJarsDir, "${version_id}-calamus-nested.jar")
def namedJar = new File(namedJarsDir, "${version_id}-named.jar")
def versionDetails = null
def versionJsons = new File(cacheFilesMinecraft, "version-jsons/")
def versionFile = new File(versionJsons, "${minecraft_version}.json")
def versionDetailsFile = new File(versionJsons, "${minecraft_version}-details.json")
def gameJars = new File(cacheFilesMinecraft, "game-jars/")
def clientJar = new File(gameJars, "${minecraft_version}-client.jar")
def serverJar = new File(gameJars, "${minecraft_version}-server.jar")
def mappingsCacheDir = new File(cacheFilesMinecraft, "mappings/")
def calamusV1File = new File(mappingsCacheDir, "${version_id}-calamus.tiny")
def calamusV2File = new File(mappingsCacheDir, "${version_id}-calamus-v2.tiny")
def nestsFile = new File(mappingsCacheDir, "${version_id}.nest")
def calamusNestsFile = new File(mappingsCacheDir, "${version_id}-calamus.nest")
def mainJar = null
def libraries = new File(cacheFilesMinecraft, "libraries/")
def libs = new File("build/libs/")

def namespace = "intermediary"

def REMOVE_DUMMY = new MappingValidator() {

	@Override
	public boolean validate(ClassMapping c) {
		if (!MappingsDiff.safeIsDiff(ClassMapping.getSimplified(c.src()), c.get()) && (c.get().startsWith("C_") || c.get().startsWith("net/minecraft/unmapped/C_"))) {
			c.set("");
			return !c.getJavadoc().isEmpty() || c.hasChildren();
		}

		return true;
	}

	@Override
	public boolean validate(FieldMapping f) {
		if (!MappingsDiff.safeIsDiff(f.src(), f.get()) && f.get().startsWith("f_")) {
			f.set("");
			return !f.getJavadoc().isEmpty();
		}

		return true;
	}

	@Override
	public boolean validate(MethodMapping m) {
		if (!MappingsDiff.safeIsDiff(m.src(), m.get()) && (m.get().startsWith("m_") || m.get().equals("<init>") || m.get().equals("<clinit>"))) {
			m.set("");
			return !m.getJavadoc().isEmpty() || m.hasChildren();
		}

		return true;
	}

	@Override
	public boolean validate(ParameterMapping p) {
		if (p.get().startsWith("p_")) {
			p.set("");
			return !p.getJavadoc().isEmpty();
		}

		return true;
	}
};
def INSERT_DUMMY = new MappingsDiffValidator() {

	@Override
	public boolean validate(ClassDiff c) {
		return check(c);
	}

	@Override
	public boolean validate(FieldDiff f) {
		return check(f);
	}

	@Override
	public boolean validate(MethodDiff m) {
		return check(m);
	}

	@Override
	public boolean validate(ParameterDiff p) {
		return check(p);
	}

	private boolean check(Diff d) {
		if (d.isDiff()) {
			if (d.get(DiffSide.A).isEmpty()) {
				// new mappings should be ignored, as any un-mapped members
				// should already be present as dummy mappings
				System.out.println("ignoring illegal change " + d);
				return false;
			}
			if (d.get(DiffSide.B).isEmpty()) {
				// removing a mapping is changed into a dummy mapping
				if (d.target() == MappingTarget.CLASS) {
					d.set(DiffSide.B, ClassMapping.getSimplified(d.src()));
				} else if (d.target() == MappingTarget.PARAMETER) {
					d.set(DiffSide.B, "p_" + ((ParameterDiff)d).getIndex());
				} else {
					d.set(DiffSide.B, d.src());
				}
			}
		}

		return true;
	}
};

static boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		//noinspection GrDeprecatedAPIUsage
		def hash = Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString() == checksum
	}
	return false
}

task downloadVersionsManifest {
	group = setupGroup
	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	def manifestFile = new File(cacheFilesMinecraft, "version_manifest_v2.json")
	outputs.file(manifestFile)
	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		FileUtils.copyURLToFile(new URL("https://skyrising.github.io/mc-versions/version_manifest.json"), manifestFile)
	}
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, Charset.defaultCharset())) : null
	return manifest != null ? manifest.versions.stream().filter({
		(it.id == minecraft_version)
	}).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest) {
	group = setupGroup
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

	//have to grab the release time as there's a current timestamp on each element?!
	inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

	outputs.file versionFile
	outputs.upToDateWhen {
		return false
	}

	doLast {
		manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		//nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || versionFile.exists()) {

			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
			}
		} else {
			throw new RuntimeException("No version data for Minecraft version ${minecraft_version} (Did you forget to set the MC_VERSION environment variable?)")
		}
	}

}

task downloadVersionDetails(dependsOn: downloadVersionsManifest) {
	group = setupGroup
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
	inputs.property "manifestUrl", manifestVersion.isPresent() ? manifestVersion.get().url : -1

	outputs.file versionDetailsFile
	outputs.upToDateWhen {
		return false
	}

	doLast {
		manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		//nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || versionDetailsFile.exists()) {
			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().details), versionDetailsFile)
			}
		} else {
			throw new RuntimeException("No version details for Minecraft version ${minecraft_version} (Did you forget to set the MC_VERSION environment variable?)")
		}

		versionDetails = new JsonSlurper().parseText(FileUtils.readFileToString(versionDetailsFile, Charset.defaultCharset()))

		if (versionDetails.sharedMappings) {
			if (!environment.isMerged()) {
				throw new RuntimeException("Minecraft version ${minecraft_version} is only available as merged but was requested for ${environment}!")
			}
		} else {
			if (environment.isMerged()) {
				throw new RuntimeException("Minecraft version ${minecraft_version} cannot be merged - please select either the client or server environment!")
			}
			if (environment.isClient() && !versionDetails.client) {
				throw new RuntimeException("Minecraft version ${minecraft_version} does not have a client jar!")
			}
			if (environment.isServer() && !versionDetails.server) {
				throw new RuntimeException("Minecraft version ${minecraft_version} does not have a server jar!")
			}
		}

		switch (environment) {
		case Environment.CLIENT:
			mainJar = clientJar
			break
		case Environment.SERVER:
			mainJar = serverJar
			break
		case Environment.MERGED:
			mainJar = mergedJar
			break
		}
	}
}

task downloadMcJars(dependsOn: downloadVersionDetails) {
    group = setupGroup
    inputs.files versionDetailsFile

    outputs.files(clientJar, serverJar)
    outputs.upToDateWhen {
        def validClient = (!environment.isClient() || (clientJar.exists() && validateChecksum(clientJar, versionDetails.downloads.client.sha1)))
        def validServer = (!environment.isServer() || (serverJar.exists() && validateChecksum(serverJar, versionDetails.downloads.server.sha1)))

        return validClient && validServer
    }

    doLast {
        if (!versionDetailsFile.exists() || versionDetails == null) {
            throw new RuntimeException("Can't download the jars without the ${versionDetailsFile.name} file!")
        }

        logger.lifecycle(":downloading minecraft jar(s) for ${version_id}")

        if (environment.isClient()) {
            download {
                src new URL(versionDetails.downloads.client.url)
                dest clientJar
                overwrite false
            }
        }
        if (environment.isServer()) {
            download {
                src new URL(versionDetails.downloads.server.url)
                dest serverJar
                overwrite false
            }
        }
    }
}

task downloadCalamus(dependsOn: downloadMcJars, type: Download) {
	group = buildMappingGroup
	def url = "https://github.com/OrnitheMC/calamus/raw/main/mappings/${version_id}.tiny"
	src UrlEscapers.urlFragmentEscaper().escape(url)
	dest calamusV1File
}

task downloadCalamusV2(dependsOn: downloadMcJars, type: Download) {
	group = buildMappingGroup
	def url = "https://maven.ornithemc.net/releases/net/ornithemc/calamus-${namespace}/${version_id}/calamus-${namespace}-${version_id}-v2.jar"
	src UrlEscapers.urlFragmentEscaper().escape(url)
	dest new File(mappingsCacheDir, "${version_id}-calamus-v2.jar")

	outputs.file(calamusV2File)

	doLast {
		copy {
			from({ zipTree(downloadCalamusV2.dest) }) {
				from 'mappings/mappings.tiny'
				rename 'mappings.tiny', "../${calamusV2File.name}"
			}

			into calamusV2File.parentFile
		}
	}
}

task downloadNests() {
	outputs.file(nestsFile)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		try {
			download {
				src new URL("https://github.com/OrnitheMC/nests/raw/main/nests/${version_id}.nest")
				dest nestsFile
				overwrite true
			}
		} catch (Exception ignored) {
			// not all versions have/need nests
		}
	}
}

task mergeJars(dependsOn: downloadMcJars) {
	group = setupGroup
	inputs.files downloadMcJars.outputs.files.files

	outputs.file(mergedJar)
	outputs.upToDateWhen {
		return false
	}

	doLast {
		if (environment.isMerged() && !mergedJar.exists()) {
			logger.lifecycle(":merging jars")
			def jarMerger = new JarMerger(clientJar, serverJar, mergedJar)
			jarMerger.merge()
			jarMerger.close()
		}
	}
}

task downloadMcLibs(dependsOn: downloadWantedVersionManifest) {
	group = setupGroup
	inputs.files versionFile

	outputs.dir(libraries)

	outputs.upToDateWhen { false }

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, StandardCharsets.UTF_8))

		logger.lifecycle(":downloading minecraft libraries")

		if (!libraries.exists()) {
			libraries.mkdirs()
		}

		version.libraries.each {
			if (it.downloads == null) {
				return;
			}

			def artifact = it.downloads.artifact
			if (artifact == null) return
			def downloadUrl = artifact.url

			download {
				src downloadUrl
				dest new File(libraries, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))
				overwrite false
			}

			project.dependencies.add("decompileClasspath", it.name)
		}
	}
}

task invertCalamus(dependsOn: downloadCalamus, type: FileOutput) {
	group = buildMappingGroup
	def v1Input = downloadCalamus.dest

	output = new File(mappingsCacheDir, "${version_id}-calamus-inverted.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":building inverted calamus")

		String[] v1Args = [
				v1Input.getAbsolutePath(),
				output.getAbsolutePath(),
				namespace, "official"
		]

		new CommandReorderTiny().run(v1Args)
	}
}

task invertCalamusV2(dependsOn: downloadCalamusV2, type: FileOutput) {
	group = buildMappingGroup
	def v2Input = new File(mappingsCacheDir, "${version_id}-calamus-v2.tiny")

	output = new File(mappingsCacheDir, "${version_id}-calamus-inverted-v2.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":building inverted calamus v2")

		String[] v2Args = [
				v2Input.getAbsolutePath(),
				output.getAbsolutePath(),
				namespace, "official"
		]

		new CommandReorderTinyV2().run(v2Args)
	}
}

task patchCalamus(dependsOn: [mergeJars, downloadCalamus]) {
	group = buildMappingGroup
	def calamusTinyInput = downloadCalamus.dest

	def outputFile = new File(mappingsCacheDir, "${version_id}-calamus-full.tiny")
	outputs.file(outputFile)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":patching calamus")

		String[] args = [
				mainJar.getAbsolutePath(),
				calamusTinyInput.getAbsolutePath(),
				outputFile.getAbsolutePath(),
				"--writeAll"
		]

		new CommandRewriteCalamus().run(args)
	}
}

task mapCalamusJar(dependsOn: [downloadMcLibs, downloadCalamus, mergeJars]) {
	group = mapJarGroup
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(calamusJar)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":mapping minecraft to calamus")

		mapJar(calamusJar, mainJar, downloadCalamus.dest, libraries, "official", namespace)
	}
}

task patchNests(dependsOn: [downloadNests, downloadCalamus]) {
	outputs.file(calamusNestsFile)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		if (nestsFile.exists()) {
			logger.lifecycle(":mapping nests to calamus")
			MappingUtils.mapNests(nestsFile.toPath(), calamusNestsFile.toPath(), Format.TINY_V1, calamusV1File.toPath())
		}
	}
}

task nestJar(dependsOn: [mapCalamusJar, patchNests]) {
	group = setupGroup

	outputs.file(nestedJar)
	outputs.upToDateWhen {
		return false
	}

	doLast {
		logger.lifecycle(":nesting jar")

		if (calamusNestsFile.exists()) {
			Nester.nestJar(new Nester.Options().silent(true), Paths.get(calamusJar.getAbsolutePath()), Paths.get(nestedJar.getAbsolutePath()), Paths.get(calamusNestsFile.getAbsolutePath()))
		}
	}
}

task separateMappings(dependsOn: patchNests) {
	group = featherGroup
	inputs.dir mappingsDir
	outputs.dirs(workingMappings)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":separating mappings for ${version_id}")

		VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsDir.toPath())
		Mappings mappings = MappingUtils.separateMappings(graph, version_id);

		if (calamusNestsFile.exists()) {
			Nests nests = Nests.empty()
			NesterIo.read(nests, calamusNestsFile.toPath())

			mappings = MappingUtils.applyNests(mappings, nests)
		}

		mappings.setValidator(REMOVE_DUMMY)
		Format.ENIGMA_DIR.writeMappings(workingMappings.toPath(), mappings)
	}
}

static def insertMappings(version_id, mappingsDir, workingMappingsPath, nestsPath, dir, validator) {
	VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsDir);

	Mappings separatedMappings = MappingUtils.separateMappings(graph, version_id);
	Mappings workingMappings = Format.ENIGMA_DIR.readMappings(workingMappingsPath);
	// enigma format does not have namespace info...
	workingMappings.setSrcNamespace(separatedMappings.getSrcNamespace())
	workingMappings.setDstNamespace(separatedMappings.getDstNamespace())

	if (nestsPath.toFile().exists()) {
		Nests nests = Nests.empty()
		NesterIo.read(nests, nestsPath)

		workingMappings = MappingUtils.undoNests(workingMappings, nests)
	}

	MappingsDiff changes = MappingUtils.diffMappings(separatedMappings, workingMappings);
	changes.setValidator(validator);

	PropagationOptions options = new PropagationOptions.Builder().setPropagationDirection(dir).lenient().build();
	MappingUtils.insertMappings(options, graph, changes, version_id);

	net.ornithemc.mappingutils.FileUtils.delete(workingMappingsPath.toFile())
}

task insertMappings(dependsOn: patchNests) {
	group = featherGroup
	doLast {
		logger.lifecycle(":saving mappings for ${version_id}")

		insertMappings(version_id, mappingsDir.toPath(), workingMappings.toPath(), calamusNestsFile.toPath(), PropagationDirection.NONE, INSERT_DUMMY)
	}
}

task propagateMappingsDown(dependsOn: patchNests) {
	group = featherGroup
	doLast {
		logger.lifecycle(":saving mappings for ${version_id}")

		insertMappings(version_id, mappingsDir.toPath(), workingMappings.toPath(), calamusNestsFile.toPath(), PropagationDirection.DOWN, INSERT_DUMMY)
	}
}

task propagateMappingsUp(dependsOn: patchNests) {
	group = featherGroup
	doLast {
		logger.lifecycle(":saving mappings for ${version_id}")

		insertMappings(version_id, mappingsDir.toPath(), workingMappings.toPath(), calamusNestsFile.toPath(), PropagationDirection.UP, INSERT_DUMMY)
	}
}

task propagateMappings(dependsOn: patchNests) {
	group = featherGroup
	doLast {
		logger.lifecycle(":saving mappings for ${version_id}")

		insertMappings(version_id, mappingsDir.toPath(), workingMappings.toPath(), calamusNestsFile.toPath(), PropagationDirection.BOTH, INSERT_DUMMY)
	}
}

task feather(dependsOn: [nestJar, separateMappings]) {
	group = featherGroup
	doLast {
		ant.setLifecycleLogLevel "WARN"
		ant.java(
				classname: 'cuchaz.enigma.gui.Main',
				classpath: configurations.enigmaRuntime.asPath,
				fork: true,
				spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: (calamusNestsFile.exists() ? nestedJar : calamusJar).getAbsolutePath())
			arg(value: '-mappings')
			arg(value: workingMappings.getAbsolutePath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

task separateMappingsForBuild(type: WithV2FileOutput) {
	inputs.dir mappingsDir

	v1Output = new File(tempDir, "separated-mappings.tiny")
	v2Output = new File(tempDir, "separated-mappings-v2.tiny")

	outputs.upToDateWhen { false }

	doLast {
		VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsDir.toPath())
		Mappings mappings = MappingUtils.separateMappings(graph, version_id);

		mappings.setValidator(REMOVE_DUMMY)
		Format.TINY_V2.writeMappings(v2Output.toPath(), mappings)

		new ConvertMappingsCommand().run(
			"tinyv2",
			v2Output.getAbsolutePath(),
			"tiny:${namespace}:named",
			v1Output.getAbsolutePath())
	}
}

task checkMappings(dependsOn: [mapCalamusJar, separateMappingsForBuild]) {
	group = buildMappingGroup
	inputs.file separateMappingsForBuild.v2Output
	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
				mainJar.getAbsolutePath(),
				separateMappingsForBuild.v2Output.getAbsolutePath()
		]

		try {
			new CheckMappingsCommand().run(args)
		} catch (IllegalStateException ignored) {
			// just print, don't fail the task
		}
	}
}

task buildFeatherTiny(dependsOn: [mapCalamusJar, separateMappingsForBuild], type: WithV2FileOutput) {
	group = buildMappingGroup
	inputs.file separateMappingsForBuild.v2Output
	if (!libs.exists()) {
		libs.mkdirs()
	}

	v1Output = new File(tempDir, "feather-mappings.tiny")
	v2Output = new File(tempDir, "feather-mappings-v2.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":generating tiny mappings")

		new MapSpecializedMethodsCommand().run(
				calamusJar.getAbsolutePath(),
				"tinyv2",
				separateMappingsForBuild.v2Output.getAbsolutePath(),
				"tinyv2:${namespace}:named",
				v2Output.getAbsolutePath()
		)

		new ConvertMappingsCommand().run(
				"tinyv2",
				v2Output.getAbsolutePath(),
				"tiny:${namespace}:named",
				v1Output.getAbsolutePath())
	}
}

task mergeTiny(dependsOn: ["buildFeatherTiny", "invertCalamus"], type: FileOutput) {
	group = buildMappingGroup
	def featherTinyInput = buildFeatherTiny.v1Output
	def calamusTinyInput = invertCalamus.output

	def unorderedResultMappings = new File(tempDir, "mappings-unordered.tiny")
	output = new File(tempDir, "mappings.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":merging feather and calamus")
		String[] args = [
				calamusTinyInput.getAbsolutePath(),
				featherTinyInput.getAbsolutePath(),
				unorderedResultMappings.getAbsolutePath(),
				namespace,
				"official"
		]

		new CommandMergeTiny().run(args)

		logger.lifecycle(":reordering merged calamus")
		String[] args2 = [
				unorderedResultMappings.getAbsolutePath(),
				output.getAbsolutePath(),
				"official", namespace, "named"
		]

		new CommandReorderTiny().run(args2)
	}
}

task tinyJar(type: Jar, dependsOn: mergeTiny) {
	group = buildMappingGroup
	outputs.upToDateWhen { false }
	archiveFileName = "feather-${featherVersion}.jar"
	destinationDirectory.set(file("build/libs"))
	archiveClassifier.set("")
	from(mergeTiny.output) {
		rename { "mappings/mappings.tiny" }
	}
}

task compressTiny(dependsOn: [tinyJar, mergeTiny], type: FileOutput) {
	group = buildMappingGroup
	def outputFile = new File(libs, "feather-tiny-${featherVersion}.gz")
	outputs.file(outputFile)
	output = outputFile

	def inputFile = mergeTiny.output

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":compressing tiny mappings")

		def buffer = new byte[1024]
		def fileOutputStream = new FileOutputStream(outputFile)
		def outputStream = new GZIPOutputStream(fileOutputStream)
		def fileInputStream = new FileInputStream(inputFile)

		def length
		while ((length = fileInputStream.read(buffer)) > 0) {
			outputStream.write(buffer, 0, length)
		}

		fileInputStream.close()
		outputStream.finish()
		outputStream.close()
	}
}

clean.doFirst {
	delete tempDir, cacheFilesMinecraft
}

tasks.build.dependsOn "compressTiny", "tinyJar", "v2UnmergedFeatherJar", "v2MergedFeatherJar"

task exportMappingsOfficial(dependsOn: downloadCalamus) {
	def composeInput = downloadCalamus.dest

	doLast {
		logger.lifecycle(":exporting mappings")
		String[] args = [
				"tiny",
				composeInput.getAbsolutePath(),
				"enigma",
				file("mappings/").getAbsolutePath(),
				"enigma",
				file("mappings_official/").getAbsolutePath(),
				"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task importMappingsOfficial(dependsOn: invertCalamus) {
	def composeInput = invertCalamus.output

	doLast {
		logger.lifecycle(":importing mappings")
		String[] args = [
				"tiny",
				composeInput.getAbsolutePath(),
				"enigma",
				file("mappings_official/").getAbsolutePath(),
				"enigma",
				file("mappings/").getAbsolutePath(),
				"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task buildTinyWithEnum(dependsOn: "mergeTiny", type: FileOutput) {
	group = buildMappingGroup
	def noEnum = mergeTiny.output
	output = new File(tempDir, "named-with-enum.tiny")

	outputs.file(output)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":seeking auto-mappable fields")

		String[] argsPropose = [
				mainJar.getAbsolutePath(), // must use official jar
				noEnum.getAbsolutePath(),
				output.getAbsolutePath()
		]

		new CommandProposeFieldNames().run(argsPropose)
	}
}

task mapNamedJar(dependsOn: ["mergeV2", mapCalamusJar]) {
	group = mapJarGroup
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(namedJar)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":mapping minecraft to named")

		mapJar(namedJar, calamusJar, mergeV2.output, libraries, namespace, "named")
	}
}

task insertAutoGeneratedEnumMappings(dependsOn: [buildFeatherTiny, mapCalamusJar], type: FileOutput) {
	group = buildMappingGroup
	def noEnumV2 = buildFeatherTiny.v2Output
	output = new File(tempDir, "unmerged-named-v2-with-enum.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":seeking auto-mappable fields for unmerged mappings")

		String[] argsProposeV2 = [
				calamusJar.getAbsolutePath(), // must use calamus jar
				noEnumV2.getAbsolutePath(),
				output.getAbsolutePath(),
				"false" // don't replace existing names right now
		]

		new CommandProposeV2FieldNames().run(argsProposeV2)
	}
}

task mergeV2(dependsOn: ["v2UnmergedFeatherJar", "invertCalamusV2"], type: FileOutput) {
	def mergedV2 = new File(tempDir, "merged-v2.tiny")

	output = new File(tempDir, "merged-reordered-v2.tiny")
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":merging feather and calamus v2")
		String[] args = [
				invertCalamusV2.output.getAbsolutePath(),
				insertAutoGeneratedEnumMappings.output.getAbsolutePath(),
				mergedV2.getAbsolutePath(),
				namespace,
				"official"
		]

		new CommandMergeTinyV2().run(args)

		//Reorder the mappings to match the output of loom
		args = [
				mergedV2.getAbsolutePath(),
				output.getAbsolutePath(),
				"official",
				namespace,
				"named"
		]
		new CommandReorderTinyV2().run(args)
	}
}

task v2UnmergedFeatherJar(dependsOn: insertAutoGeneratedEnumMappings, type: Jar) {
	def mappings = insertAutoGeneratedEnumMappings.output
	group = "mapping build"
	outputs.upToDateWhen { false }
	archiveFileName = "feather-${featherVersion}-v2.jar"

	from(file(mappings)) {
		rename mappings.name, "mappings/mappings.tiny"
	}
	destinationDirectory.set(file("build/libs"))
}

task v2MergedFeatherJar(dependsOn: ["mergeV2"], type: Jar) {
	def mappings = mergeV2.output
	group = "mapping build"
	outputs.upToDateWhen { false }
	archiveFileName = "feather-${featherVersion}-mergedv2.jar"

	from(file(mappings)) {
		rename mappings.name, "mappings/mappings.tiny"
	}
	destinationDirectory.set(file("build/libs"))
}

def fakeSourceDir = file(".gradle/temp/fakeSource")
task genFakeSource(type: JavaExec, dependsOn: ["mergeV2", "mapNamedJar"]) {
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	if (!JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17)) {
		javaLauncher.set(javaToolchains.launcherFor {
			languageVersion = JavaLanguageVersion.of(17)
		})
	}

	mainClass.set("net.fabricmc.mappingpoet.Main")
	classpath configurations.mappingPoet
	// use merged v2 so we have all namespaces in jd
	args mergeV2.output.getAbsolutePath(), namedJar.getAbsolutePath(), fakeSourceDir.getAbsolutePath(), libraries.getAbsolutePath()

	doLast {
		logger.lifecycle ":Fake source generated"
	}
}

task decompileCFR(type: JavaExec, dependsOn: "mapNamedJar") {
	classpath = configurations.decompileClasspath
	mainClass.set("org.benf.cfr.reader.Main")

	args namedJar.getAbsolutePath(), "--outputdir", file("namedSrc").absolutePath

	doFirst {
		file("namedSrc").deleteDir()
	}
}

task decompileQuiltFlower(type: JavaExec, dependsOn: "mapNamedJar") {
	classpath = configurations.decompileClasspath
	mainClass.set("org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler")

	args namedJar.getAbsolutePath(), file("namedSrc").absolutePath

	doFirst {
		file("namedSrc").deleteDir()
	}
}

static List<String> getFilesInJar(String jarPath) {
	List<String> classNames = new ArrayList<String>()
	ZipInputStream zip = new ZipInputStream(new FileInputStream(jarPath))
	for (ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {
		if (!entry.isDirectory() && entry.getName().endsWith(".class")) {
			String className = entry.getName()
			classNames.add(className.substring(0, className.length() - ".class".length()))
		}
	}
	return classNames
}


static def decompileUsingProcyon(String jarPath, String outputDir) {
	DecompilerSettings settings = DecompilerSettings.javaDefaults()
	JarFile jar = new JarFile(jarPath)
	settings.setTypeLoader(new JarTypeLoader(jar))

	List<String> classNames = getFilesInJar(jarPath)
	for (String name : classNames) {
		String dirPath = (outputDir + File.separator + name.substring(0, name.lastIndexOf('/'))).replace('/', File.separator)
		String filePath = (dirPath + name.substring(name.lastIndexOf('/')) + ".java").replace('/', File.separator)
		File dir = new File(dirPath)
		dir.mkdirs()
		println "Mapping: " + name
		try (final FileOutputStream stream = new FileOutputStream(filePath)
			 final OutputStreamWriter writer = new OutputStreamWriter(stream)) {

			Decompiler.decompile(
					name,
					new PlainTextOutput(writer),
					settings
			)
			writer.close()
		}
		catch (final IOException e) {
			println e
		}
	}

}


task decompileProcyon(dependsOn: "mapNamedJar") {
	doFirst {
		file("namedSrc").deleteDir()
		File directory = new File(file("namedSrc").absolutePath)
		directory.mkdirs()
	}

	doLast {
		logger.lifecycle("decompile class")
		decompileUsingProcyon(namedJar.getAbsolutePath(), file("namedSrc").absolutePath)
	}
}

javadoc {
	dependsOn genFakeSource
	dependsOn downloadMcLibs
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	def mappingPoetJar = project.provider { zipTree configurations.mappingPoetJar.singleFile }

	failOnError = false
	maxMemory = '2G'

	if (!JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17)) {
		javadocTool.set(javaToolchains.javadocToolFor {
			languageVersion = JavaLanguageVersion.of(17)
		})
	}
	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "11"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "net.fabricmc.mappingpoet.jd.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred

		addBooleanOption "-allow-script-in-comments", true
		links(
				'https://guava.dev/releases/21.0/api/docs/',
				'https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.0/',
				'https://logging.apache.org/log4j/2.x/log4j-api/apidocs/',
				// jsr305 need to come before jdk or the anno links are broken
				'https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.2/',
				'https://javadoc.lwjgl.org/',
				'https://fastutil.di.unimi.it/docs/',
				'https://netty.io/4.1/api/',
				'https://commons.apache.org/proper/commons-logging/javadocs/api-1.1.3/',
				'https://commons.apache.org/proper/commons-lang/javadocs/api-3.5',
				'https://commons.apache.org/proper/commons-io/javadocs/api-2.5',
				'https://commons.apache.org/proper/commons-codec/archives/1.10/apidocs',
				'https://commons.apache.org/proper/commons-compress/javadocs/api-1.8.1/',
				"https://maven.quiltmc.org/javadocs/release/net/quiltmc/quilt-loader-${project.quilt_loader_version}/",
				"https://docs.oracle.com/en/java/javase/11/docs/api/"
				// Need to add loader jd publication for env annotations!
		)
		// https://docs.oracle.com/en/java/javase/17/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
	}
	source fakeSourceDir
	classpath = configurations.javadocClasspath.plus downloadMcLibs.outputs.files.asFileTree

	doLast {
		project.copy {
			from mappingPoetJar
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath configurations.mappingPoet.files.toList()
			header mappingPoetJar.get().filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim()
			// cannot include line breaks
			addFileOption "-add-stylesheet", mappingPoetJar.get().filter { it.name == 'forms.css' }.singleFile
		}
	}
}

task javadocJar(type: Jar, dependsOn: ["javadoc"]) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set featherVersion
	archiveClassifier.set('javadoc')
}

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'net.ornithemc'
			artifactId "feather"
			version featherVersion

			artifact(compressTiny.output) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact(tinyJar)
			artifact(v2UnmergedFeatherJar) {
				classifier "v2"
			}
			artifact(v2MergedFeatherJar) {
				classifier "mergedv2"
			}
			artifact javadocJar
		}

	}
	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url ENV.MAVEN_URL
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
				authentication {
					basic(BasicAuthentication)
				}
			}
		}
	}
}


static void mapJar(File output, File input, File mappings, File libraries, String from, String to,
				   Action<TinyRemapper.Builder> action = {}) {
	if (output.exists()) {
		output.delete()
	}

	def remapperBuilder = TinyRemapper.newRemapper()
			.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
	action.execute(remapperBuilder)
	def remapper = remapperBuilder
			.build()

	try {
		def outputConsumerBuilder = new OutputConsumerPath.Builder(output.toPath())
		def outputConsumer = outputConsumerBuilder.build()
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		libraries.eachFileRecurse(FileType.FILES) { file ->
			remapper.readClassPath(file.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

abstract class FileOutput extends DefaultTask {
	@OutputFile
	File output
}

abstract class FileOutputInput extends DefaultTask {
	@InputFile
	File input

	@OutputFile
	File output
}

abstract class WithV2FileOutput extends DefaultTask {
	@OutputFile
	File v1Output
	@OutputFile
	File v2Output
}
